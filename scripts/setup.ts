#!/usr/bin/env tsx
import { createInterface } from 'readline'
import { execSync, spawnSync } from 'child_process'
import { readFileSync, writeFileSync, existsSync, mkdirSync } from 'fs'
import { fileURLToPath } from 'url'
import path from 'path'
import os from 'os'

const __dirname = path.dirname(fileURLToPath(import.meta.url))
const PROJECT_ROOT = path.resolve(__dirname, '..')

// ---------------------------------------------------------------------------
// ANSI colours (work on Windows 10+ and all UNIX)
// ---------------------------------------------------------------------------

const G = '\x1b[32m'  // green
const Y = '\x1b[33m'  // yellow
const R = '\x1b[31m'  // red
const B = '\x1b[1m'   // bold
const D = '\x1b[2m'   // dim
const C = '\x1b[36m'  // cyan
const RESET = '\x1b[0m'

const ok = (msg: string) => console.log(`${G}✓${RESET} ${msg}`)
const warn = (msg: string) => console.log(`${Y}⚠${RESET}  ${msg}`)
const fail = (msg: string) => console.log(`${R}✗${RESET} ${msg}`)
const info = (msg: string) => console.log(`${C}→${RESET} ${msg}`)
const header = (msg: string) => console.log(`\n${B}${msg}${RESET}`)
const dim = (msg: string) => console.log(`${D}${msg}${RESET}`)

// ---------------------------------------------------------------------------
// Readline helpers
// ---------------------------------------------------------------------------

const rl = createInterface({ input: process.stdin, output: process.stdout })

function ask(question: string, defaultValue = ''): Promise<string> {
  const prompt = defaultValue
    ? `${question} ${D}[${defaultValue}]${RESET} `
    : `${question} `
  return new Promise(resolve => {
    rl.question(prompt, answer => {
      const trimmed = answer.trim()
      resolve(trimmed === '' ? defaultValue : trimmed)
    })
  })
}

function askSecret(question: string, defaultValue = ''): Promise<string> {
  const prompt = defaultValue
    ? `${question} ${D}[${defaultValue.slice(0, 4)}…]${RESET} `
    : `${question} `
  return new Promise(resolve => {
    rl.question(prompt, answer => {
      const trimmed = answer.trim()
      resolve(trimmed === '' ? defaultValue : trimmed)
    })
  })
}

function askYesNo(question: string, defaultYes = true): Promise<boolean> {
  const hint = defaultYes ? 'Y/n' : 'y/N'
  return new Promise(resolve => {
    rl.question(`${question} [${hint}] `, answer => {
      const t = answer.trim().toLowerCase()
      if (t === '') resolve(defaultYes)
      else resolve(t === 'y' || t === 'yes')
    })
  })
}

// ---------------------------------------------------------------------------
// .env helpers
// ---------------------------------------------------------------------------

function readExistingEnv(): Record<string, string> {
  const envPath = path.join(PROJECT_ROOT, '.env')
  if (!existsSync(envPath)) return {}
  const existing: Record<string, string> = {}
  for (const line of readFileSync(envPath, 'utf8').split('\n')) {
    const trimmed = line.trim()
    if (!trimmed || trimmed.startsWith('#')) continue
    const eq = trimmed.indexOf('=')
    if (eq === -1) continue
    const k = trimmed.slice(0, eq).trim()
    let v = trimmed.slice(eq + 1).trim()
    if ((v.startsWith('"') && v.endsWith('"')) || (v.startsWith("'") && v.endsWith("'"))) {
      v = v.slice(1, -1)
    }
    if (k) existing[k] = v
  }
  return existing
}

function writeEnv(values: Record<string, string>): void {
  const lines = [
    '# ClaudeClaw configuration — generated by npm run setup',
    '',
    '# --- Telegram ---',
    `TELEGRAM_BOT_TOKEN=${values['TELEGRAM_BOT_TOKEN'] ?? ''}`,
    `ALLOWED_CHAT_ID=${values['ALLOWED_CHAT_ID'] ?? ''}`,
    '',
    '# --- Voice (optional) ---',
    `GROQ_API_KEY=${values['GROQ_API_KEY'] ?? ''}`,
    `ELEVENLABS_API_KEY=${values['ELEVENLABS_API_KEY'] ?? ''}`,
    `ELEVENLABS_VOICE_ID=${values['ELEVENLABS_VOICE_ID'] ?? ''}`,
    '',
    '# --- Video analysis (optional) ---',
    `GOOGLE_API_KEY=${values['GOOGLE_API_KEY'] ?? ''}`,
    '',
    '# --- Multi-user mode (optional) ---',
    `MULTIUSER=${values['MULTIUSER'] ?? 'false'}`,
  ]
  writeFileSync(path.join(PROJECT_ROOT, '.env'), lines.join('\n') + '\n', 'utf8')
}

// ---------------------------------------------------------------------------
// Build
// ---------------------------------------------------------------------------

function tryExec(cmd: string, cwd?: string): string | null {
  try {
    return execSync(cmd, {
      cwd: cwd ?? PROJECT_ROOT,
      encoding: 'utf8',
      stdio: ['pipe', 'pipe', 'pipe'],
    }).trim()
  } catch {
    return null
  }
}

// ---------------------------------------------------------------------------
// Background service
// ---------------------------------------------------------------------------

function installMacService(startCmd: string): void {
  const plistDir = path.join(os.homedir(), 'Library', 'LaunchAgents')
  const plistPath = path.join(plistDir, 'com.claudeclaw.app.plist')

  mkdirSync(plistDir, { recursive: true })

  const nodeExe = process.execPath
  const [, ...args] = startCmd.split(' ')

  const plist = `<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
  <key>Label</key>
  <string>com.claudeclaw.app</string>
  <key>ProgramArguments</key>
  <array>
    <string>${nodeExe}</string>
    ${args.map(a => `<string>${a}</string>`).join('\n    ')}
  </array>
  <key>WorkingDirectory</key>
  <string>${PROJECT_ROOT}</string>
  <key>RunAtLoad</key>
  <true/>
  <key>KeepAlive</key>
  <true/>
  <key>ThrottleInterval</key>
  <integer>10</integer>
  <key>StandardOutPath</key>
  <string>/tmp/claudeclaw.log</string>
  <key>StandardErrorPath</key>
  <string>/tmp/claudeclaw.log</string>
</dict>
</plist>`

  writeFileSync(plistPath, plist, 'utf8')
  tryExec(`launchctl unload "${plistPath}"`)
  const result = tryExec(`launchctl load "${plistPath}"`)
  if (result !== null) {
    ok(`launchd service installed and started`)
    dim(`  Logs: /tmp/claudeclaw.log`)
    dim(`  Stop: launchctl unload ~/Library/LaunchAgents/com.claudeclaw.app.plist`)
  } else {
    warn(`launchd plist written but load failed — try manually:`)
    dim(`  launchctl load "${plistPath}"`)
  }
}

function installLinuxService(): void {
  const serviceDir = path.join(os.homedir(), '.config', 'systemd', 'user')
  const servicePath = path.join(serviceDir, 'claudeclaw.service')

  mkdirSync(serviceDir, { recursive: true })

  const nodeExe = process.execPath
  const service = `[Unit]
Description=ClaudeClaw AI Assistant
After=network.target

[Service]
Type=simple
WorkingDirectory=${PROJECT_ROOT}
ExecStart=${nodeExe} ${path.join(PROJECT_ROOT, 'dist', 'index.js')}
Restart=always
RestartSec=10
StandardOutput=journal
StandardError=journal

[Install]
WantedBy=default.target
`

  writeFileSync(servicePath, service, 'utf8')
  tryExec('systemctl --user daemon-reload')
  tryExec('systemctl --user enable claudeclaw')
  const result = tryExec('systemctl --user start claudeclaw')
  if (result !== null) {
    ok(`systemd service installed and started`)
    dim(`  Logs: journalctl --user -u claudeclaw -f`)
    dim(`  Stop: systemctl --user stop claudeclaw`)
  } else {
    warn(`systemd service installed — check with:`)
    dim(`  systemctl --user status claudeclaw`)
  }
}

function showWindowsPm2Instructions(): void {
  info(`Windows service setup via PM2:`)
  console.log()
  console.log(`  ${B}1. Install PM2:${RESET}`)
  console.log(`     npm install -g pm2`)
  console.log()
  console.log(`  ${B}2. Start ClaudeClaw:${RESET}`)
  console.log(`     pm2 start "${path.join(PROJECT_ROOT, 'dist', 'index.js')}" --name claudeclaw`)
  console.log()
  console.log(`  ${B}3. Auto-start on login:${RESET}`)
  console.log(`     pm2 startup`)
  console.log(`     pm2 save`)
  console.log()
  console.log(`  ${B}4. View logs:${RESET}`)
  console.log(`     pm2 logs claudeclaw`)
}

// ---------------------------------------------------------------------------
// Main
// ---------------------------------------------------------------------------

async function main(): Promise<void> {
  // Banner
  try {
    const bannerPath = path.join(PROJECT_ROOT, 'banner.txt')
    if (existsSync(bannerPath)) {
      console.log(readFileSync(bannerPath, 'utf8'))
    } else {
      console.log(`${B}=== ClaudeClaw Setup ===${RESET}`)
    }
  } catch {
    console.log(`${B}=== ClaudeClaw Setup ===${RESET}`)
  }

  console.log(`Welcome. This wizard will configure and install ClaudeClaw.\n`)

  // ---------------------------------------------------------------------------
  // Step 1: Requirements check
  // ---------------------------------------------------------------------------

  header('Step 1: Checking requirements')

  const nodeVer = process.version
  const nodeMajor = parseInt(nodeVer.replace('v', '').split('.')[0], 10)
  if (nodeMajor >= 22) {
    ok(`Node.js ${nodeVer}`)
  } else if (nodeMajor >= 20) {
    warn(`Node.js ${nodeVer} — v22.5.0+ recommended for built-in SQLite`)
  } else {
    fail(`Node.js ${nodeVer} — requires v20+. Download from nodejs.org`)
    process.exit(1)
  }

  const claudeVer = tryExec('claude --version')
  if (claudeVer) {
    ok(`Claude CLI: ${claudeVer}`)
  } else {
    fail(`Claude CLI not found. Install from https://claude.ai/code and run "claude login"`)
    process.exit(1)
  }

  // ---------------------------------------------------------------------------
  // Step 2: Build
  // ---------------------------------------------------------------------------

  header('Step 2: Building project')
  info('Running npm run build...')

  const buildResult = spawnSync('npm', ['run', 'build'], {
    cwd: PROJECT_ROOT,
    encoding: 'utf8',
    shell: true,
    stdio: ['inherit', 'pipe', 'pipe'],
  })

  if (buildResult.status !== 0) {
    fail(`Build failed:\n${buildResult.stderr}`)
    process.exit(1)
  }
  ok('Build successful')

  // ---------------------------------------------------------------------------
  // Step 3: Collect configuration
  // ---------------------------------------------------------------------------

  header('Step 3: Configuration')

  const existing = readExistingEnv()
  const config: Record<string, string> = { ...existing }

  console.log(`\nYou'll need a Telegram bot token from @BotFather.`)
  dim(`  If you don't have one: open Telegram → search @BotFather → /newbot`)

  config['TELEGRAM_BOT_TOKEN'] = await askSecret(
    'Telegram bot token:',
    existing['TELEGRAM_BOT_TOKEN'] ?? ''
  )

  if (!config['TELEGRAM_BOT_TOKEN']) {
    fail('Bot token is required. Exiting.')
    process.exit(1)
  }

  console.log()
  console.log(`${B}Voice — Speech-to-text (Groq Whisper)${RESET}`)
  dim(`  Free tier at console.groq.com — lets you send voice notes to the bot`)

  const wantGroq = await askYesNo('Enable voice transcription (Groq)?', !!existing['GROQ_API_KEY'])
  if (wantGroq) {
    config['GROQ_API_KEY'] = await askSecret('Groq API key:', existing['GROQ_API_KEY'] ?? '')
  } else {
    config['GROQ_API_KEY'] = ''
  }

  console.log()
  console.log(`${B}Voice — Text-to-speech (ElevenLabs)${RESET}`)
  dim(`  Free tier at elevenlabs.io — bot replies back with your chosen voice`)

  const wantTts = await askYesNo('Enable voice replies (ElevenLabs)?', !!existing['ELEVENLABS_API_KEY'])
  if (wantTts) {
    config['ELEVENLABS_API_KEY'] = await askSecret('ElevenLabs API key:', existing['ELEVENLABS_API_KEY'] ?? '')
    config['ELEVENLABS_VOICE_ID'] = await ask('ElevenLabs voice ID:', existing['ELEVENLABS_VOICE_ID'] ?? '')
  } else {
    config['ELEVENLABS_API_KEY'] = ''
    config['ELEVENLABS_VOICE_ID'] = ''
  }

  console.log()
  console.log(`${B}Video analysis (Google Gemini)${RESET}`)
  dim(`  Free tier at aistudio.google.com — lets bot analyze video files you send`)

  const wantVideo = await askYesNo('Enable video analysis (Gemini)?', !!existing['GOOGLE_API_KEY'])
  if (wantVideo) {
    config['GOOGLE_API_KEY'] = await askSecret('Google API key:', existing['GOOGLE_API_KEY'] ?? '')
  } else {
    config['GOOGLE_API_KEY'] = ''
  }

  // Write .env (without chat ID yet — filled in step 5)
  config['ALLOWED_CHAT_ID'] = existing['ALLOWED_CHAT_ID'] ?? ''
  config['MULTIUSER'] = existing['MULTIUSER'] ?? 'false'
  writeEnv(config)
  ok('.env written')

  // ---------------------------------------------------------------------------
  // Step 4: Personalize CLAUDE.md
  // ---------------------------------------------------------------------------

  header('Step 4: Personalize your assistant')
  console.log(`CLAUDE.md is your assistant's system prompt — fill in your name and context.`)

  const claudeMdPath = path.join(PROJECT_ROOT, 'CLAUDE.md')
  const wantEdit = await askYesNo('Open CLAUDE.md in your editor now?', true)

  if (wantEdit) {
    const editor = process.env.EDITOR ?? process.env.VISUAL ?? (process.platform === 'win32' ? 'notepad' : 'nano')
    spawnSync(editor, [claudeMdPath], { stdio: 'inherit', shell: true })
    ok('CLAUDE.md saved')
  } else {
    info(`Edit it later: ${claudeMdPath}`)
  }

  // ---------------------------------------------------------------------------
  // Step 5: Get chat ID
  // ---------------------------------------------------------------------------

  header('Step 5: Get your Telegram chat ID')

  if (config['ALLOWED_CHAT_ID']) {
    ok(`Chat ID already configured: ${config['ALLOWED_CHAT_ID']}`)
  } else {
    console.log(`\nSend /chatid to your bot to get your chat ID.`)
    console.log(`After entering your chat ID here, only you can use the bot.\n`)

    const chatId = await ask(
      'Your Telegram chat ID (press Enter to skip and configure later):',
      ''
    )

    if (chatId) {
      config['ALLOWED_CHAT_ID'] = chatId
      writeEnv(config)
      ok(`Chat ID saved: ${chatId}`)
    } else {
      warn('Chat ID skipped — bot will accept messages from ANYONE until you set ALLOWED_CHAT_ID in .env')
    }
  }

  // ---------------------------------------------------------------------------
  // Step 6: Install background service
  // ---------------------------------------------------------------------------

  header('Step 6: Background service')

  const platform = process.platform
  const wantService = await askYesNo(
    'Install as background service (auto-start on login)?',
    true
  )

  if (wantService) {
    if (platform === 'darwin') {
      installMacService(`node ${path.join(PROJECT_ROOT, 'dist', 'index.js')}`)
    } else if (platform === 'linux') {
      installLinuxService()
    } else {
      showWindowsPm2Instructions()
    }
  } else {
    info(`Start manually: npm start`)
  }

  // ---------------------------------------------------------------------------
  // Summary
  // ---------------------------------------------------------------------------

  header('Setup complete')
  console.log()

  const todos: string[] = []
  if (!config['ALLOWED_CHAT_ID']) {
    todos.push('Set ALLOWED_CHAT_ID in .env (send /chatid to your bot to find it)')
  }
  if (!wantGroq) todos.push('Optional: add GROQ_API_KEY to .env for voice transcription')
  if (!wantTts) todos.push('Optional: add ELEVENLABS_API_KEY + ELEVENLABS_VOICE_ID for voice replies')
  if (!wantVideo) todos.push('Optional: add GOOGLE_API_KEY to .env for video analysis')

  if (todos.length > 0) {
    console.log(`${B}To-do:${RESET}`)
    for (const item of todos) {
      console.log(`  ${Y}•${RESET} ${item}`)
    }
    console.log()
  }

  if (!wantService || platform === 'win32') {
    console.log(`${B}Start the bot:${RESET}`)
    console.log(`  npm start`)
    console.log()
  }

  console.log(`${B}Check status anytime:${RESET}`)
  console.log(`  npm run status`)
  console.log()
  console.log(`${G}You're all set. Message your bot on Telegram to get started.${RESET}`)
  console.log()

  rl.close()
}

main().catch(err => {
  console.error(`${R}Fatal error:${RESET}`, err)
  rl.close()
  process.exit(1)
})
